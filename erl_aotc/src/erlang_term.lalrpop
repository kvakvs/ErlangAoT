/// This parser takes Erlang Term as a string, and parses it.
///
use std::str::FromStr; // for numeric types ::from_str()
use fterm::FTerm;

grammar;

pub DottedTerm: FTerm = {
  <t:Term> "." => t
};

pub Term: FTerm = {
  // A list is 0 or more terms separated by comma (tolerates trailing comma)
  "[" <lst:Terms> "]" => match lst.len() {
    0 => FTerm::EmptyList,
    _ => FTerm::List(lst),
  },
  // A tuple is 0 or more terms separated by comma (tolerates trailing comma)
  "{" <lst:Terms> "}" => match lst.len() {
    0 => FTerm::EmptyTuple,
    _ => FTerm::Tuple(lst),
  },

  QuotedAtom,
  NakedAtom,
  Int64,
  Str,
};

Int64: FTerm = {
  // An integer has an optional sign followed by digits
  <i: r"[+-]?[0-9]+"> => FTerm::Int64(i64::from_str(i).unwrap()),
}

// A quoted atom
QuotedAtom: FTerm = {
  <a: r#"'([^']+)'"#> => FTerm::Atom(a[1..a.len() - 1].to_string())
}

// A double-quoted string consisting of any characters other than `"`
Str: FTerm = {
  <a: r#""([^"]*)""#> => FTerm::String(a[1..a.len() - 1].to_string())
}

// An atom is a word starting with lowercase or underscore, followed by any
// letter, digit or underscore
NakedAtom: FTerm = {
  <a:r"[a-z_][A-Za-z0-9_]*"> => FTerm::Atom(a.to_string())
}

// Comma-separated list of Terms
Terms = Comma<Term>; // (0)

// A generic macro which defines a comma-separated list of T (see the LALRPOP
// tutorial, section on Macros)
Comma<T>: Vec<T> = { // (1)
  <v:(<T> ",")*> <e:T?> => match e { // (2)
    None => v,
    Some(e) => {
      let mut v1 = v;
      v1.push(e);
      v1
    }
  }
};
